# Ćwiczenie 05: Service Layer

## Zadanie

Refaktoruj `NoteController` do architektury warstwowej.

### Docelowa struktura

```
note/
├── NoteController.java      # HTTP routing only
├── NoteService.java         # Business logic
├── InMemoryNoteRepository.java  # Data storage
├── Note.java                # Domain model
└── dto/
    ├── CreateNoteRequest.java
    ├── UpdateNoteRequest.java
    └── NoteResponse.java
```

### NoteController (thin)

```java
@RestController
@RequestMapping("/api/notes")
public class NoteController {
    
    private final NoteService noteService;
    
    public NoteController(NoteService noteService) {
        this.noteService = noteService;
    }
    
    @GetMapping
    public List<NoteResponse> getAll() {
        return noteService.findAll();
    }
    
    @PostMapping
    public NoteResponse create(@RequestBody CreateNoteRequest request) {
        return noteService.create(request);
    }
    // ... reszta deleguje do service
}
```

### NoteService

```java
@Service
public class NoteService {
    
    private final InMemoryNoteRepository repository;
    
    public NoteService(InMemoryNoteRepository repository) {
        this.repository = repository;
    }
    
    public List<NoteResponse> findAll() {
        return repository.findAll().stream()
            .map(this::toResponse)
            .toList();
    }
    
    public NoteResponse create(CreateNoteRequest request) {
        Note note = new Note(
            null, // ID generated by repository
            request.title(),
            request.content(),
            request.author(),
            LocalDateTime.now()
        );
        return toResponse(repository.save(note));
    }
    
    private NoteResponse toResponse(Note note) {
        return new NoteResponse(
            note.id(),
            note.title(),
            note.content(),
            note.author(),
            note.createdAt()
        );
    }
}
```

### InMemoryNoteRepository

```java
@Repository
public class InMemoryNoteRepository {
    
    private final Map<Long, Note> storage = new ConcurrentHashMap<>();
    private final AtomicLong idGenerator = new AtomicLong(1);
    
    public Note save(Note note) {
        Long id = note.id() != null ? note.id() : idGenerator.getAndIncrement();
        Note saved = new Note(id, note.title(), note.content(), 
                              note.author(), note.createdAt());
        storage.put(id, saved);
        return saved;
    }
    
    public Optional<Note> findById(Long id) {
        return Optional.ofNullable(storage.get(id));
    }
    
    public List<Note> findAll() {
        return List.copyOf(storage.values());
    }
    
    public void deleteById(Long id) {
        storage.remove(id);
    }
    
    public boolean existsById(Long id) {
        return storage.containsKey(id);
    }
}
```

## Checklist

- [ ] Controller nie ma żadnej logiki (tylko wywołuje service)
- [ ] Service nie wie o HTTP (nie używa ResponseEntity)
- [ ] Repository nie wie o DTO (operuje na Note)
- [ ] Wszystkie zależności przez constructor injection
